# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will ru
# Triggers for the workflow
on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  # Job 1: Build the project and create an output
  build:
    name: 1. Build Project
    runs-on: ubuntu-latest
    
    # This section defines the outputs that this job will produce
    outputs:
      build_id: ${{ steps.set_build_id.outputs.id }}

    steps:
      - name: Print a welcome message
        run: echo "ðŸ‘‹ Starting the build process..."

      - name: Set Build ID
        id: set_build_id
        # We generate a unique build ID and save it as an output
        run: echo "id=build-${{ github.run_number }}-${RANDOM}" >> "$GITHUB_OUTPUT"

      - name: Add note to Job Summary
        run: echo "### âœ… Build Completed" >> $GITHUB_STEP_SUMMARY
  
  # Job 2: Run tests after the build is successful
  test:
    name: 2. Run Tests
    runs-on: ubuntu-latest
    # This job will only start after the 'build' job has finished successfully
    needs: build
    
    steps:
      - name: Checkout repository code
        uses: actions/checkout@v4

      - name: Run tests (simulation)
        run: |
          echo "ðŸ§ª Running unit tests..."
          echo "ðŸ§ª Running integration tests..."
          sleep 5 # Simulate a longer test run
          echo "All tests passed!"
          
      - name: Generate Test Report in Job Summary
        uses: actions/github-script@v7
        with:
          script: |
            await core.summary
              .addHeading('ðŸ“Š Test Results')
              .addTable([
                [{data: 'Test Suite', header: true}, {data: 'Result', header: true}],
                ['Unit Tests', 'Pass âœ…'],
                ['Integration Tests', 'Pass âœ…'],
                ['Security Scan', 'Pass âœ…']
              ])
              .write()

  # Job 3: Deploy to a staging environment for review
  deploy_staging:
    name: 3. Deploy to Staging
    runs-on: ubuntu-latest
    # This job depends on both 'build' and 'test' finishing successfully
    needs: [build, test]
    
    environment:
      name: staging
      url: https://staging.example.com/build-${{ needs.build.outputs.build_id }}

    steps:
      - name: Deploy to Staging Server
        run: |
          echo "ðŸš€ Deploying Build ID: ${{ needs.build.outputs.build_id }} to Staging..."
          sleep 10 # Simulate deployment
          echo "âœ… Deployed successfully to ${{ job.environment.url }}"

      - name: Update Job Summary with Staging URL
        run: |
          echo "### ðŸš€ Deployed to Staging" >> $GITHUB_STEP_SUMMARY
          echo "You can view the deployment here: ${{ job.environment.url }}" >> $GITHUB_STEP_SUMMARY

  # Job 4: Deploy to the production environment (final step)
  deploy_production:
    name: 4. Deploy to Production
    runs-on: ubuntu-latest
    # This job only runs after staging deployment is successful
    needs: deploy_staging
    
    # This makes the job only run on the main branch, a good practice for production
    if: github.ref == 'refs/heads/main'

    environment:
      name: production
      url: https://production.example.com/build-${{ needs.build.outputs.build_id }}

    steps:
      - name: Deploy to Production Server
        run: |
          echo "ðŸš¨ DEPLOYING TO PRODUCTION! Build ID: ${{ needs.build.outputs.build_id }}"
          sleep 15 # Simulate a longer, more critical deployment
          echo "âœ… Successfully deployed to Production: ${{ job.environment.url }}"
      
      - name: Dump GitHub context for debugging
        if: always() # This step runs even if previous steps fail
        run: echo "${{ toJSON(github) }}"
